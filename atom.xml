<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rerunbug.github.io</id>
    <title>Ruble</title>
    <updated>2021-01-17T12:11:21.630Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rerunbug.github.io"/>
    <link rel="self" href="https://rerunbug.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://rerunbug.github.io/images/avatar.png</logo>
    <icon>https://rerunbug.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Ruble</rights>
    <entry>
        <title type="html"><![CDATA[snow]]></title>
        <id>https://rerunbug.github.io/_jNZEphCG/</id>
        <link href="https://rerunbug.github.io/_jNZEphCG/">
        </link>
        <updated>2021-01-17T12:07:41.000Z</updated>
        <content type="html"><![CDATA[<p>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高速复习HTML]]></title>
        <id>https://rerunbug.github.io/HzsAwj0ss/</id>
        <link href="https://rerunbug.github.io/HzsAwj0ss/">
        </link>
        <updated>2021-01-14T15:19:45.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://rerunbug.github.io/post-images/1610639254235.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高速上手C++14/17]]></title>
        <id>https://rerunbug.github.io/yn-wIBJMj/</id>
        <link href="https://rerunbug.github.io/yn-wIBJMj/">
        </link>
        <updated>2020-12-21T03:54:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="高速上手-c-1114">高速上手 C++ 11/14</h1>
<h2 id="引言">引言</h2>
<p>C++ 算是一个用户群体比较大的语言了，从 C++98 到 C++11 经历了长达十年多之久的积累，C++14 则是作为对 C++11 的重要补充和优化，所有这些新标准中扩充的特性，给 C++ 这门语言注入了新的活力。<br>
那些还在坚持使用<strong>传统 C++</strong> （本教程把 C++98 及其之前的 C++ 特性均称之为传统 C++）而未接触过 C++11/14 的 C++ 程序员在见到诸如 Lambda 表达式这类全新特性时，甚至会流露出『学的不是同一门语言』的惊叹之情。</p>
<p><strong>C++1x</strong> (本教程中指 C++11/14, 甚至 C++17) 为传统 C++ 注入的大量特性使得整个 C++ 变得更加像一门现代化的语言。C++1x 不仅仅增强了 C++ 语言自身的可用性，<code>auto</code> 关键字语义的修改使得我们更加有信心来操控极度复杂的模板类型。同时还对语言运行期进行了大量的强化，Lambda 表达式的出现让 C++ 具有了『匿名函数』的『闭包』特性，而这一特性几乎在现代的编程语言（诸如 Python/Swift/... ）中已经司空见惯，右值引用的出现解决了 C++ 长期以来被人诟病的临时对象效率问题等等。</p>
<p>C++1x 为自身的标准库增加了非常多的工具和方法，诸如在语言层面上提供了 <code>std::thread</code> 支持了并发编程，在不同平台上不再依赖于系统底层的 API，实现了语言层面的跨平台支持；<code>std::regex</code>提供了完整的正则表达式支持等等。C++98 已经被实践证明了是一种非常成功的『范型』，而 C++1x 的出现，则进一步推动这种范型，让 C++ 成为系统程序设计和库开发更好的语言。</p>
<h2 id="目标读者">目标读者</h2>
<ol>
<li>本教程假定读者已经熟悉了传统 C++ ，至少在阅读传统 C++ 代码上不具备任何困难。换句话说，那些长期使用传统 C++进行编码的人、渴望在短时间内迅速了解 <strong>Modern C++</strong> 特性的人非常适合阅读本书；</li>
<li>本教程一定程度上介绍了一些 C++1x 的<strong>黑魔法</strong>，但这些魔法毕竟有限，不适合希望进阶学习 C++1x 的读者，本教程的定位系<strong>C++1x 的快速上手</strong>。当然，希望进阶学习的读者可以使用本书来回顾并检验自己对 <strong>Modern C++</strong> 的熟悉度。</li>
</ol>
<h2 id="本书目的">本书目的</h2>
<p>本教程号称高速上手教程，从内容上对 C++11/14/17 （与惯例不同，本书决定统一称为 C++1x）的相关特性做了一个相对全面的介绍，读者可以自行根据下面的目录选取感兴趣的内容进行学习，快速熟悉需要了解的内容，这从某种意义上来说，也算是高速上手了。</p>
<p>这些特性并不需要全部掌握，只需针对特定的应用场景，学习、查阅最适合自己的新特性即可。</p>
<p>值得一提的是，<strong>本教程在介绍这些特性的过程中，尽可能简单明了的介绍了这些特性产生的历史背景和技术需求，这为理解这些特性、运用这些特性提供了很大的帮助。</strong></p>
<h2 id="目录">目录</h2>
<blockquote>
<p>正在向支持 C++17 的内容过度</p>
</blockquote>
<ul>
<li><strong>第一章 C++11/14 简介</strong>
<ul>
<li>概述</li>
<li>被弃用的特性</li>
<li>与 C 的兼容性</li>
</ul>
</li>
<li><strong>第二章 语言可用性的强化</strong>
<ul>
<li>
<p><code>nullptr</code> 与 <code>constexpr</code></p>
</li>
<li>
<p>类型推导</p>
<ul>
<li><code>auto</code></li>
<li><code>decltype</code></li>
<li>尾返回类型、<code>auto</code> 与 <code>decltype</code> 配合</li>
</ul>
  <!--+ decltype(auto) (C++14)-->
</li>
<li>
<p>区间迭代</p>
<ul>
<li>基于范围的 for 循环</li>
</ul>
</li>
<li>
<p>初始化列表</p>
<ul>
<li><code>std::initializer_list</code></li>
<li>统一初始化语法</li>
</ul>
</li>
<li>
<p>模板增强</p>
<ul>
<li>外部模板</li>
<li>尖括号 <code>&gt;</code></li>
<li>类型别名模板</li>
<li>变长参数模板</li>
</ul>
</li>
<li>
<p>面向对象增强</p>
<ul>
<li>委托构造</li>
<li>继承构造</li>
<li>显式虚函数重载
<ul>
<li><code>override</code></li>
<li><code>final</code></li>
</ul>
</li>
<li>显式禁用默认函数</li>
</ul>
</li>
<li>
<p>强类型枚举</p>
</li>
</ul>
</li>
<li><strong>第三章 语言运行期的强化</strong>
<ul>
<li>lambda 表达式
<ul>
<li>lambda 表达式基础
<ul>
<li>值捕获</li>
<li>引用捕获</li>
<li>隐式捕获</li>
<li>表达式捕获</li>
</ul>
</li>
<li>泛型 lambda</li>
</ul>
</li>
<li>函数对象包装器
<ul>
<li>std::function</li>
<li>std::bind/std::placeholder</li>
</ul>
</li>
<li>右值引用
<ul>
<li>左值、右值的纯右值、将亡值、右值</li>
<li>右值引用和左值引用</li>
<li>移动语义</li>
<li>完美转发</li>
</ul>
</li>
</ul>
</li>
<li><strong>第四章 对标准库的扩充: 新增容器</strong>
<ul>
<li><code>std::array</code></li>
<li><code>std::forward_list</code></li>
<li><code>std::unordered_set</code></li>
<li><code>std::unordered_map</code></li>
<li><code>std::tuple</code>
<ul>
<li>基本操作</li>
<li>运行期索引</li>
<li>合并与迭代</li>
</ul>
</li>
</ul>
</li>
<li><strong>第五章 对标准库的扩充: 智能指针和引用计数</strong>
<ul>
<li>RAII 与引用计数</li>
<li><code>std::shared_ptr</code></li>
<li><code>std::unique_ptr</code></li>
<li><code>std::weak_ptr</code></li>
</ul>
</li>
<li><strong>第六章 对标准库的扩充: 正则表达式库</strong>
<ul>
<li>正则表达式简介
<ul>
<li>普通字符</li>
<li>特殊字符</li>
<li>限定符</li>
</ul>
</li>
<li><code>std::regex</code> 及其相关
<ul>
<li><code>std::regex</code></li>
<li><code>std::regex_match</code></li>
<li><code>std::match_results</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>第七章 对标准库的扩充: 语言级线程支持</strong>
<ul>
<li><code>std::thread</code></li>
<li><code>std::mutex</code></li>
<li><code>std::unique_lock</code></li>
<li><code>std::future</code></li>
<li><code>std::packaged_task</code></li>
<li><code>std::condition_variable</code></li>
</ul>
</li>
<li><strong>第八章 其他杂项</strong>
<ul>
<li>新类型
<ul>
<li><code>long long int</code></li>
</ul>
</li>
<li><code>noexcept</code> 的修饰和操作</li>
<li>字面量
<ul>
<li>原始字符串字面量</li>
<li>自定义字面量</li>
</ul>
</li>
</ul>
</li>
<li><strong>第九章 扩展主题: C++17 简介</strong>
<ul>
<li>主要入选特性
<ul>
<li>非类型模板参数的 <code>auto</code></li>
<li><code>std::variant&lt;&gt;</code></li>
<li>结构化绑定(Structured bindings)</li>
<li>变量声明的强化</li>
</ul>
</li>
<li>未入选特性
<ul>
<li>Concepts</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="许可">许可</h2>
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png" /></a></p>
<p>本教程由<a href="https://github.com/changkun">欧长坤</a>撰写，采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>许可。项目中代码使用 MIT 协议开源，参见<a href="../LICENSE">许可</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[追风筝的人]]></title>
        <id>https://rerunbug.github.io/6JWVqqmzH/</id>
        <link href="https://rerunbug.github.io/6JWVqqmzH/">
        </link>
        <updated>2020-12-06T13:57:51.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://rerunbug.github.io/post-images/1607263132678.jpg" alt="" loading="lazy"><br>
作者：[美] 卡勒德·胡赛尼<br>
对于这本书我想说，它更像是在讲述一个真实且就好像是发生在身边是事情那样。这本书给我的力量绝非一般而是很大。时间真的可以将过去的种种冲淡吗？还是我们不愿意去面对，而选择去逃避。而真正的勇士是敢于面对生活的惨淡，敢于正视淋漓的鲜血。勇士是敢于知道这个世界的真相之后还敢于直面生活的人。<br>
阿富汗的少爷阿米尔和其仆人哈桑。在童年时，哈桑是一个放风筝的天才，至于掉落的风筝他都能准确无误的预判到风筝掉落的地方，在阿米尔问他是怎么知道的，哈桑又反问少爷：“我有骗过你吗？<font color="red">为你，千千万万遍。</font>看到这里我就回想到了小时候也曾经有过这一段真挚的友情。<font color="red">为你，千千万万遍。</font>这句话在一个未经世事的儿童口中说出来我认为此子将来在肯定是一个很重情谊的人，是一个很值得交的朋友，但是在社会上很容易吃亏的人。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[哥儿]]></title>
        <id>https://rerunbug.github.io/KXm_pk_us/</id>
        <link href="https://rerunbug.github.io/KXm_pk_us/">
        </link>
        <updated>2020-11-25T02:17:49.000Z</updated>
        <content type="html"><![CDATA[<p><strong>作者：夏目漱石</strong><br>
<img src="https://rerunbug.github.io/post-images/1606270829037.jpg" alt="" loading="lazy"><br>
我第次看夏目漱石的作品是《心》讲述的是一个孤独患者的故事。现在忘记的差不多了。<br>
《哥儿》中的少爷的原型是 弘中又一，少爷是一个作事仅凭个人感觉做事的人，正如清婆<br>
说的“少爷您善良，正义”少爷在我们中国古代就有一种侠客的风范，少爷在物理学院毕业<br>
后就远离了东京去了一个偏僻的地方教书了，在哪里遇见了“红衬衫”，”豪猪“，”蹩脚帮“<br>
，&quot;狗瓘”。少爷起初还以为“豪猪”是坏人结果是“红衬衫”“蹩脚帮”才是坏人第一点挑唆<br>
学生去我的蚊帐里面放蚂蚱，在去“红衬衫”家吃饭下套让我们去劝架，结果诱导报社写我们去<br>
打架了。反而“红衬衫”整天把为人师表，要严于律己，身为老师要起带头作用。“豪猪”与少爷<br>
都是不懂如何在人世中圆滑出世的”侠客“少爷就是一种被别人卖了还在为别人数钱的人。”蹩脚帮“<br>
与”红衬衫“狼狈为奸。而”狗瓘“作为校长却无作为。少爷与”豪猪“采用了比较侠客的方法报复<br>
了回去，在妓院的门口蹲点等他们出现打了一顿，又以侠客的方式声明我就在旅馆等他们报警啥的，<br>
仿佛就像告诉他你要来报复我，我随时恭候的到来。<br>
这篇小说通篇看下来毫无压力看完后还有点爽，我内心也住着个侠客，但是如果在现代为人不圆滑就会成为别人砧板上的鱼肉，少爷与”豪猪“他们虽然成功了，但是也失去了教师的工作，少爷从40元/月的工作去到了25元/月的工作而且还很辛苦，写到这里我想到了一个很中二的台词：”错的不是我，而是这个世界“在文章的结尾夏目漱石还写了一段关于清婆的事情清婆死与肝炎，缺少清婆的少爷如何在这个两面三刀的世界上活着，在往后的几年里少爷是否还能保持初心呢？是否成为了与这个世界同流合污的那一类人呢？现在问题仿佛就像是在问读者。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[冒泡排序法]]></title>
        <id>https://rerunbug.github.io/tQVI77KYT/</id>
        <link href="https://rerunbug.github.io/tQVI77KYT/">
        </link>
        <updated>2020-11-14T15:17:53.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://rerunbug.github.io/post-images/1605367181856.png" alt="" loading="lazy"><br>
<img src="https://rerunbug.github.io/post-images/1605367188199.png" alt="" loading="lazy"></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int bubbleSort(int a[], int N) {
	int sw = 0;
	bool flag = 1;
	for (int i = 0; flag; i++) {
		flag = 0;
		for (int j = N - 1; j &gt;= i + 1; j--) {
			//大于为降序，小于为升序。
			if (a[j] &lt; a[j - 1]) {
				//交换相邻元素      这里也可以用指针来表示
				swap(a[j], a[j - 1]);//int *temp;
				flag = 1;               //*temp=a[j];
				sw++;                  //a[j]=a[j-1];
			}                               //a[j-1]=*temp;
		}
	}
	return sw;
}
int main()
{
	int a[100], n, sw;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; a[i];
	}
	sw = bubbleSort(a, n);
	for (int i = 0; i &lt; n; i++) {
		if (i)cout &lt;&lt; &quot; &quot;;
		cout &lt;&lt; a[i];
	}
	cout &lt;&lt; endl;
	cout &lt;&lt; sw &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>冒泡排序法用c++比较方便一些<br>
可以看到作比较的函数是数组的最后一个与倒数第二个<br>
作比较的（众所周知3个数组里面所分配的空间命名为<br>
a[0],a[1],a[2]是从0到n-1个数来分配内存空间的）如果<br>
大于就将他们的值交换。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[插入排序法]]></title>
        <id>https://rerunbug.github.io/RQJCmKtJJ/</id>
        <link href="https://rerunbug.github.io/RQJCmKtJJ/">
        </link>
        <updated>2020-11-14T15:05:47.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://rerunbug.github.io/post-images/1605366613526.png" alt="" loading="lazy"><br>
<img src="https://rerunbug.github.io/post-images/1605366622087.png" alt="" loading="lazy"></p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
//按顺序输出数组元素
void trace(int A[], int N)
{
	int i;
	for (i = 0; i &lt; N; i++) {
		if (i &gt; 0)printf(&quot; &quot;);//在相邻元素之间输出1个空格
		printf(&quot;%d&quot;, A[i]);
	}
	printf(&quot;\n&quot;);
}
//插入排序（0起点数组）
void insertionSort(int A[], int N) {
	int j, i, v;
	for (i = 1; i &lt; N; i++) {
		v = A[i];
		j = i - 1;
		while (j &gt;= 0 &amp;&amp; A[j] &gt; v) {
			A[j + 1] = A[j];
			j--;
		}
		A[j + 1] = v;
		trace(A, N);
	}
}
int main() {
	int N, i;
	int A[100];
	scanf_s(&quot;%d&quot;, &amp;N);
	for (i = 0; i &lt; N; i++)scanf_s(&quot;%d&quot;, &amp;A[i]);
	trace(A, N);
	insertionSort(A, N);
	return 0;
}
</code></pre>
<p>第一次循环a[0]和a[1]作对比如果a[0]大于等于0并且大于a[1]<br>
就把a[0]的值与a[1]的值交换。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Using Git]]></title>
        <id>https://rerunbug.github.io/UEcFGE4HJ/</id>
        <link href="https://rerunbug.github.io/UEcFGE4HJ/">
        </link>
        <updated>2020-11-13T11:24:45.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Git下载链接</strong><br>
<a href="https://gitforwindows.org/">Git</a><br>
一路安装下去<br>
<img src="https://rerunbug.github.io/post-images/1605267005371.jpg" alt="" loading="lazy"><br>
按照这样设置<br>
安装好后我们鼠标右键会发现多出了两个命令<br>
一个是Git GUI Here   和   Git Bash Here<br>
我们新建一个<font color="red">空</font>文件夹<br>
然后打开这个文件夹鼠标右键按Git Bash Here<br>
等一会会出现<br>
<img src="https://rerunbug.github.io/post-images/1605267312288.jpg" alt="" loading="lazy"><br>
键入git init 命令注意空格<br>
查看文件夹的隐藏文件会发现多出一个文件.git<br>
在gitee or github 新建好一个仓库以后。<br>
我们键入git remote origin 加上地址<br>
origin 可以任意名称<br>
我们可以键入git remote -v查看是否完成了导入仓库<br>
git add . 代表添加所用文件注意  .  的空格<br>
git add 文件名<br>
git status 查看添加目录<br>
git commit -m&quot;&quot;   添加描述 必须的<br>
git push origin master 推送到git上<br>
有时候我们无法成功推送上去我们可以键入<br>
git push origin master -f 命令强制推送上去<br>
在团队项目中我们要养成push前要pull项目<br>
git pull origin master<br>
要不然会把之前队友的文件覆盖了的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ESP定律]]></title>
        <id>https://rerunbug.github.io/aREf_pDTx/</id>
        <link href="https://rerunbug.github.io/aREf_pDTx/">
        </link>
        <updated>2020-11-08T06:56:27.000Z</updated>
        <content type="html"><![CDATA[<p><font color="red">ESP定律又名堆栈平衡定律。</font><br>
<strong>典型的壳有UPX壳</strong><br>
<img src="https://rerunbug.github.io/post-images/1604819295812.jpg" alt="" loading="lazy"><br>
pushad是一个很典型的入栈代码<br>
我们在这里F8一下注意寄存器的ESP那边，只有ESP那边标红了<br>
<img src="https://rerunbug.github.io/post-images/1604819553832.jpg" alt="" loading="lazy"><br>
然后我们在红字部分转到内存部分<br>
在第一个字节下一个硬件访问断点4字节<br>
然后F9来到<br>
<img src="https://rerunbug.github.io/post-images/1604819891609.jpg" alt="" loading="lazy"><br>
看到0046DE7C这里的jmp是一个大跳转F8过去就来到了<br>
OEP<br>
<img src="https://rerunbug.github.io/post-images/1604820089795.jpg" alt="" loading="lazy"><br>
因为这只是一个压缩壳，所以他没有加密IAT直接脱就好了<br>
这里我们用dbg自带的插件来脱<br>
按ctrl+i<br>
<img src="https://rerunbug.github.io/post-images/1604820279590.jpg" alt="" loading="lazy"><br>
OEP自动填写上去了<br>
之后我们按IAT Autosearch按钮之后VA和SIZE的数据也会帮我们填上去了<br>
然后按Get Imports后我们可以看到表格里面列有很多数据<br>
我们把打<font color="red">×</font>的数据按鼠标右键Delte tree node删除即可<br>
然后按Dump按钮会得到一个exe文件，注意这个无法打开的我们还需要Fix Dump文件<br>
按下这个按钮选择我们刚刚得到的Dump文件即可运行了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[子序列的和（subsequence）]]></title>
        <id>https://rerunbug.github.io/xdJMwwQ9W/</id>
        <link href="https://rerunbug.github.io/xdJMwwQ9W/">
        </link>
        <updated>2020-11-07T10:24:27.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://rerunbug.github.io/post-images/1604744763984.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
double c;
int main()
{
	long long int n, m,a,j=1;
	while (scanf_s(&quot;%lld %lld&quot;, &amp;n, &amp;m) !=EOF)
	{
		if (n == 0 &amp;&amp; m == 0)break;
		for (a=n; a &lt;= m; a++)
		{
			c +=1.0/(a*a);
		}
		printf(&quot;Case %d:&quot;, j++);
		printf(&quot;%.5lf\n&quot;, c);
	}
	return 0;
}
</code></pre>
<p><strong>在c+=1.0/(a*a)这里我也中了坑，c语言里面int/int 得到的是int型的数据，而int/float类型的数据就会强制转化为int型的数据。只有float/float才会为有小数的值</strong></p>
]]></content>
    </entry>
</feed>