<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rerunbug.github.io</id>
    <title>Ruble</title>
    <updated>2020-11-14T15:29:43.474Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rerunbug.github.io"/>
    <link rel="self" href="https://rerunbug.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://rerunbug.github.io/images/avatar.png</logo>
    <icon>https://rerunbug.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Ruble</rights>
    <entry>
        <title type="html"><![CDATA[冒泡排序法]]></title>
        <id>https://rerunbug.github.io/tQVI77KYT/</id>
        <link href="https://rerunbug.github.io/tQVI77KYT/">
        </link>
        <updated>2020-11-14T15:17:53.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://rerunbug.github.io/post-images/1605367181856.png" alt="" loading="lazy"><br>
<img src="https://rerunbug.github.io/post-images/1605367188199.png" alt="" loading="lazy"></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int bubbleSort(int a[], int N) {
	int sw = 0;
	bool flag = 1;
	for (int i = 0; flag; i++) {
		flag = 0;
		for (int j = N - 1; j &gt;= i + 1; j--) {
			//大于为降序，小于为升序。
			if (a[j] &lt; a[j - 1]) {
				//交换相邻元素      这里也可以用指针来表示
				swap(a[j], a[j - 1]);//int *temp;
				flag = 1;               //*temp=a[j];
				sw++;                  //a[j]=a[j-1];
			}                               //a[j-1]=*temp;
		}
	}
	return sw;
}
int main()
{
	int a[100], n, sw;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; a[i];
	}
	sw = bubbleSort(a, n);
	for (int i = 0; i &lt; n; i++) {
		if (i)cout &lt;&lt; &quot; &quot;;
		cout &lt;&lt; a[i];
	}
	cout &lt;&lt; endl;
	cout &lt;&lt; sw &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>冒泡排序法用c++比较方便一些<br>
可以看到作比较的函数是数组的最后一个与倒数第二个<br>
作比较的（众所周知3个数组里面所分配的空间命名为<br>
a[0],a[1],a[2]是从0到n-1个数来分配内存空间的）如果<br>
大于就将他们的值交换。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[插入排序法]]></title>
        <id>https://rerunbug.github.io/RQJCmKtJJ/</id>
        <link href="https://rerunbug.github.io/RQJCmKtJJ/">
        </link>
        <updated>2020-11-14T15:05:47.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://rerunbug.github.io/post-images/1605366613526.png" alt="" loading="lazy"><br>
<img src="https://rerunbug.github.io/post-images/1605366622087.png" alt="" loading="lazy"></p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
//按顺序输出数组元素
void trace(int A[], int N)
{
	int i;
	for (i = 0; i &lt; N; i++) {
		if (i &gt; 0)printf(&quot; &quot;);//在相邻元素之间输出1个空格
		printf(&quot;%d&quot;, A[i]);
	}
	printf(&quot;\n&quot;);
}
//插入排序（0起点数组）
void insertionSort(int A[], int N) {
	int j, i, v;
	for (i = 1; i &lt; N; i++) {
		v = A[i];
		j = i - 1;
		while (j &gt;= 0 &amp;&amp; A[j] &gt; v) {
			A[j + 1] = A[j];
			j--;
		}
		A[j + 1] = v;
		trace(A, N);
	}
}
int main() {
	int N, i;
	int A[100];
	scanf_s(&quot;%d&quot;, &amp;N);
	for (i = 0; i &lt; N; i++)scanf_s(&quot;%d&quot;, &amp;A[i]);
	trace(A, N);
	insertionSort(A, N);
	return 0;
}
</code></pre>
<p>第一次循环a[0]和a[1]作对比如果a[0]大于等于0并且大于a[1]<br>
就把a[0]的值与a[1]的值交换。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Using Git]]></title>
        <id>https://rerunbug.github.io/UEcFGE4HJ/</id>
        <link href="https://rerunbug.github.io/UEcFGE4HJ/">
        </link>
        <updated>2020-11-13T11:24:45.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Git下载链接</strong><br>
<a href="https://gitforwindows.org/">Git</a><br>
一路安装下去<br>
<img src="https://rerunbug.github.io/post-images/1605267005371.jpg" alt="" loading="lazy"><br>
按照这样设置<br>
安装好后我们鼠标右键会发现多出了两个命令<br>
一个是Git GUI Here   和   Git Bash Here<br>
我们新建一个<font color="red">空</font>文件夹<br>
然后打开这个文件夹鼠标右键按Git Bash Here<br>
等一会会出现<br>
<img src="https://rerunbug.github.io/post-images/1605267312288.jpg" alt="" loading="lazy"><br>
键入git init 命令注意空格<br>
查看文件夹的隐藏文件会发现多出一个文件.git<br>
在gitee or github 新建好一个仓库以后。<br>
我们键入git remote origin 加上地址<br>
origin 可以任意名称<br>
我们可以键入git remote -v查看是否完成了导入仓库<br>
git add . 代表添加所用文件注意  .  的空格<br>
git add 文件名<br>
git status 查看添加目录<br>
git commit -m&quot;&quot;   添加描述 必须的<br>
git push origin master 推送到git上<br>
有时候我们无法成功推送上去我们可以键入<br>
git push origin master -f 命令强制推送上去<br>
在团队项目中我们要养成push前要pull项目<br>
git pull origin master<br>
要不然会把之前队友的文件覆盖了的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ESP定律]]></title>
        <id>https://rerunbug.github.io/aREf_pDTx/</id>
        <link href="https://rerunbug.github.io/aREf_pDTx/">
        </link>
        <updated>2020-11-08T06:56:27.000Z</updated>
        <content type="html"><![CDATA[<p><font color="red">ESP定律又名堆栈平衡定律。</font><br>
<strong>典型的壳有UPX壳</strong><br>
<img src="https://rerunbug.github.io/post-images/1604819295812.jpg" alt="" loading="lazy"><br>
pushad是一个很典型的入栈代码<br>
我们在这里F8一下注意寄存器的ESP那边，只有ESP那边标红了<br>
<img src="https://rerunbug.github.io/post-images/1604819553832.jpg" alt="" loading="lazy"><br>
然后我们在红字部分转到内存部分<br>
在第一个字节下一个硬件访问断点4字节<br>
然后F9来到<br>
<img src="https://rerunbug.github.io/post-images/1604819891609.jpg" alt="" loading="lazy"><br>
看到0046DE7C这里的jmp是一个大跳转F8过去就来到了<br>
OEP<br>
<img src="https://rerunbug.github.io/post-images/1604820089795.jpg" alt="" loading="lazy"><br>
因为这只是一个压缩壳，所以他没有加密IAT直接脱就好了<br>
这里我们用dbg自带的插件来脱<br>
按ctrl+i<br>
<img src="https://rerunbug.github.io/post-images/1604820279590.jpg" alt="" loading="lazy"><br>
OEP自动填写上去了<br>
之后我们按IAT Autosearch按钮之后VA和SIZE的数据也会帮我们填上去了<br>
然后按Get Imports后我们可以看到表格里面列有很多数据<br>
我们把打<font color="red">×</font>的数据按鼠标右键Delte tree node删除即可<br>
然后按Dump按钮会得到一个exe文件，注意这个无法打开的我们还需要Fix Dump文件<br>
按下这个按钮选择我们刚刚得到的Dump文件即可运行了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[子序列的和（subsequence）]]></title>
        <id>https://rerunbug.github.io/xdJMwwQ9W/</id>
        <link href="https://rerunbug.github.io/xdJMwwQ9W/">
        </link>
        <updated>2020-11-07T10:24:27.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://rerunbug.github.io/post-images/1604744763984.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
double c;
int main()
{
	long long int n, m,a,j=1;
	while (scanf_s(&quot;%lld %lld&quot;, &amp;n, &amp;m) !=EOF)
	{
		if (n == 0 &amp;&amp; m == 0)break;
		for (a=n; a &lt;= m; a++)
		{
			c +=1.0/(a*a);
		}
		printf(&quot;Case %d:&quot;, j++);
		printf(&quot;%.5lf\n&quot;, c);
	}
	return 0;
}
</code></pre>
<p><strong>在c+=1.0/(a*a)这里我也中了坑，c语言里面int/int 得到的是int型的数据，而int/float类型的数据就会强制转化为int型的数据。只有float/float才会为有小数的值</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[水仙花数（daffodil）]]></title>
        <id>https://rerunbug.github.io/1sX5M7cRx/</id>
        <link href="https://rerunbug.github.io/1sX5M7cRx/">
        </link>
        <updated>2020-11-07T07:40:04.000Z</updated>
        <content type="html"><![CDATA[<p><strong>输出 100~999 中的所有水仙花数。若 3 位数 ABC 满足 ABC=A3+B3+C3，则称其为水仙<br>
花数。例如 153=13+53+33，所以 153 是水仙花数</strong></p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
const int max = 999;
int main()
{
	for (int min = 100; min &lt;= max; min++) {
		int a = min / 100;//百分位
		int b = (min % 100) / 10;//十分位
		int c = min % 10;//个分位
		if ((a * a * a) + (b * b * b) + (c * c * c))printf(&quot;%d\n&quot;, min);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[后翼弃兵 The Queen's Gambit]]></title>
        <id>https://rerunbug.github.io/PM85vW1Lf/</id>
        <link href="https://rerunbug.github.io/PM85vW1Lf/">
        </link>
        <updated>2020-11-05T14:47:39.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://rerunbug.github.io/post-images/1604587726375.jpg" alt="" loading="lazy"><br>
<a href="https://movie.douban.com/subject/32579283/?tag=%E7%83%AD%E9%97%A8&amp;from=gaia">豆瓣直达</a><br>
<strong>Netflix出品必属精品</strong><br>
由于博主也不懂国际象棋所以我尽量不讲国际象棋有关。<br>
<strong>规制</strong><br>
国际象棋是双方对下的，一方用白棋，一方用黑棋。对局由执白者先行，每次走一步，双方轮流行棋，直到对局结束。各种棋子的一般走法如下：<br>
王（K）：横、直、斜都可以走，但每次限走一步。王是不可以送吃的，即任何被敌方控制的格子，己方王都不能走进去。否则，算“送王”犯规，三次就要判负。<br>
（1）除易位时外，王可走到不被对方棋子攻击的任何相邻格子，而且只能走一步（着）。<br>
（2）易位是由王和己方任何一个车一起进行的仍被视作王的一步（着）的走法。<br>
后（Q）：横、直、斜都可以走，步数不受限制，但不能越子。<br>
车（R）：横、竖均可以走，步数不受限制，不能斜走。除王车易位外不能越子。<br>
象（B）：只能斜走。格数不限，不能越子。开局时每方有两象，一个占白格，一个占黑格。<br>
马（N）：每步棋先横走或直走一格，然后再往外斜走一格；或者先斜走一格，最后再往外横走或竖走一格（即走“日”字）。可以越子，没有中国象棋中的“蹩马腿”限制。<br>
兵（P）：只能向前直走，每次只能走一格。但走第一步时，可以走一格或两格。兵的吃子方法与行棋方向不一样，它是直走斜吃，即如果兵的斜进一格内有对方棋子，就可以吃掉它而占据该格<br>
<font color="red"><strong>影评：</strong></font><br>
后翼弃兵，英文 The Queen's Gambit 又可以翻译为《女王的棋局》无论怎么翻译其实都是围绕一个中心问题来叙述的，关于独立，自由的话题<br>
这里有一个很典型的人物就是女主的后妈<br>
<img src="https://rerunbug.github.io/post-images/1604989886115.png" alt="" loading="lazy"><br>
她前期没有老公的她犹如行尸走肉一般，老公去出差自己在家里没有事情干，为此精神涣散、情绪容易失控。他老公本以为买了一台钢琴给她或许会好一些，没想到她依旧没有改变嗑药的习惯随着老公的出差次数越多她更依赖药物了。在得知她的老公无法回来了，她就彻底崩溃了。但是女主比较争气在比赛中拿下的第一并且获得的500美金，后妈看到女儿这样。她也随之坚强了起来，在交际上帮女主拜托一切烦恼，赛后听她女儿讲一些她完全不懂的国际象棋。为了儿时的梦想见了小时候的笔友，在笔友甩了她。她也没有为之伤心。并且整理好包袱在女儿的比赛的地方，演奏钢琴。但是好景不长她在当家庭主妇的时候落下很的病症，最后死与肝炎，在死后老公都没有多问她是怎么死的。后妈从一个家庭主妇变成了一个走向独立的女性。如果她还活着我相信她一定会成为一名很厉害的妈妈。<br>
<img src="https://rerunbug.github.io/post-images/1604991209663.png" alt="" loading="lazy"><br>
在女主的高中学校，有一个社团搞的差不多是名媛的东西。年轻是在高中很风光，但是她成年后推这婴儿车在逛她在年轻的很瞧不起的超市买，打折的东西。在生活满是依赖她的丈夫没一点点的独立性。<br>
<img src="https://rerunbug.github.io/post-images/1604991418407.png" alt="" loading="lazy"><br>
女主在孤儿院的时候和这位黑人女性玩得最好，她在得知女主被领养的时候非常气，为此她把女主的国际象棋的书拿走了。她很厉害，没有人领养她，她靠自己考上了大学学法的，并且学习期间赚了一些小钱给了女主参加比赛。与女主情同手足，相互扶持。看到她我想到的是，命运是掌握在自己手中的。不要让别人来告诉你该怎么做。她得知自己不会被领养的时候，已经知道这个定局了，她无法改变什么，但是她可以学习改变自己的命运，实际上她的确做到了，而且还很完美。</p>
<p>女主她很有魅力，在她青春时期也向男性显露出的她的魅力（有一说一我也被她撩到了）前前后后三次撩汉子，但是她没有依靠这些东西来获取别人的认同，她更想在比赛中得到别人的认同。在开头的封面我们可以看到女主的桌子上有很多酒和一个装这绿色药丸的瓶子。女主一直依靠这些来获得胜利的，每次用这些药丸她就可以打开新世界为此她以为是这些药物帮助她的。这些药物具有上瘾性的。在输个一个俄罗斯的大神后她就愈加依靠这些东西来慰及自己的心灵。把自己搞得不人不鬼样子，在她彻底完蛋的时候她的朋友来（上文）了帮她了。<br>
她慢慢的走出了，上瘾的状态，在决赛的时候没有依靠那些药物来维持她，她彻底摆脱了药物的依赖，并且战胜了俄罗斯的大神。写到这里我突然想到了高中时期一篇作文题目叫；有一些行李只能我们左肩换右肩来扛。我想这里很适合这个题目。在未来的未来我们必定有妻子（丈夫）和子女。在我们最危机的时候，我们可以依靠他们，但是也不能全依靠他们，他们或许自己都顾不上了，变心了。在何时何地我们的都应该有属于自己的一技之长，这样命运才不会由别人来规定。如果一直依靠别人我们始终都不会长大。一直在温室里的花朵，如果去到了外面经历了一些风吹雨打必定会“折断”。但是也不是提倡去冒险，比如说爱因斯坦现在在一直有内战的国家，你想想他还会有今天如此的成就吗？答案很明显了。我们要在父母健在的时候多多的出去历练，去多多接触外面的人和事。一直依靠别人始终都不是方法的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[指针]]></title>
        <id>https://rerunbug.github.io/zhi-zhen/</id>
        <link href="https://rerunbug.github.io/zhi-zhen/">
        </link>
        <updated>2020-11-04T23:53:53.000Z</updated>
        <content type="html"><![CDATA[<p><strong>我们都知道声明一个变量，就是声明一个内存空间。比如声明一个int型的变量相当于向计算机索要一块地方，能容纳4个字节的地方。而指针的作用就是“查户口”</strong>。<br>
下面我们来简单声明一下指针变量</p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int pointer(int*point,*u);
int main()
{
    int x=0,y=0;
    pointer(&amp;x,&amp;y);
    printf(&quot;%d %d&quot;,x,y);
}
int pointer(int*point,*u)
{
    int aver;
    aver=*point;
    *point=*u;
    *u=aver;
    return 0;
}
</code></pre>
<p><strong>需要注意的是pointer(&amp;x,&amp;y)这里用了取址运算符</strong></p>
<pre><code class="language-cpp">po=&amp;pe；
pa=*po
//相当于pa=pe这是间接赋值
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[秘密]]></title>
        <id>https://rerunbug.github.io/read-mark/</id>
        <link href="https://rerunbug.github.io/read-mark/">
        </link>
        <updated>2020-11-04T01:10:23.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>简介
<blockquote>
<p>作者：东野圭吾</p>
</blockquote>
</li>
<li>内容简介
<blockquote>
<p>平介的幸福生活在39岁那年被摧毁了。妻子带着女儿回娘家探亲，乘坐的大巴意外坠落山崖。妻子拼命护住女儿，最终伤重不治；女儿毫发未伤，但一直昏迷。妻子离世的那一刻，女儿奇迹般醒了过来。平介强忍悲痛为妻子办完葬礼，回到病房，看到女儿在熟睡，他忍不住呜咽着呼喊妻子。这时突然传来一个声音：“……公。”平介吓了一跳，却四顾无人，正疑惑时又听到了那声音：“老公，我……我在这儿。”<br>
<img src="https://rerunbug.github.io/post-images/1604581564657.jpg" alt="" loading="lazy"></p>
</blockquote>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>简介
<blockquote>
<p>作者：东野圭吾</p>
</blockquote>
</li>
<li>内容简介
<blockquote>
<p>平介的幸福生活在39岁那年被摧毁了。妻子带着女儿回娘家探亲，乘坐的大巴意外坠落山崖。妻子拼命护住女儿，最终伤重不治；女儿毫发未伤，但一直昏迷。妻子离世的那一刻，女儿奇迹般醒了过来。平介强忍悲痛为妻子办完葬礼，回到病房，看到女儿在熟睡，他忍不住呜咽着呼喊妻子。这时突然传来一个声音：“……公。”平介吓了一跳，却四顾无人，正疑惑时又听到了那声音：“老公，我……我在这儿。”<br>
<img src="https://rerunbug.github.io/post-images/1604581564657.jpg" alt="" loading="lazy"></p>
</blockquote>
</li>
</ul>
<!-- more -->
<ul>
<li>剧情简介
<blockquote>
<p>平介是一名汽车零件加工厂的工作人员。一年前升为了组长。因为年关将至厂里的业务各种多，导致不得不加班，直子是平介的妻子，藻奈美是平介的女儿。家乡有人去世了为了祭拜回去家乡，因为平介要加班，所以她们回去要乘坐大巴。平介在一篇报道中看的了“长野滑雪大巴坠崖事故”的大字标题，平介这时开始紧张了起来，因为长野滑雪大巴正是妻儿她们所乘坐的大巴啊，死亡名单里面就有她们。直子为了救藻奈美而牺牲了。在医院平介一直在藻奈美身边，医生说；由于母亲把他保护的很好，身上一点点伤都没有，现在不能说话很可能是因为受到惊吓的缘故。将近出院时藻奈美向爸爸说我是直子，直子的灵魂附身在了藻奈美身上。直子以藻奈美的身份活着。到了高中时期，情窦初开藻奈美继承了直子的美貌再加上在学校成绩都是排上号的。平介对与直子这种享受这种被人追求的感觉好像很乐在其中，对于在追求直子的人更是非常的讨厌了。由于平介对于藻奈美是他女儿，但是灵魂是他老婆这件事情很反感，毕竟想作却不能作的苦楚身为男人的都觉得很痛，所以平介就很限制直子的行动，甚至跟踪她。在直子心灰意冷的时候藻奈美的灵魂却是回来了。平介对于直子很抱歉，随着直子的灵魂一点点的消失，藻奈美的灵魂一点点的回来。平介的戒心慢慢的放下了。在一个钟表维修店，平介拿了之前的长野滑雪大巴的司机的遗物一个怀表去参加藻奈美的婚礼，新郎是那位司机的儿子。前几天藻奈美拿了妈妈出嫁时爸爸送的那枚戒指去维修店重新打造了一番。而平介拿的也是遗物双方都是遗物在婚礼现场似乎很不妙。平介顿时惊讶了，因为戒指就藏在泰迪熊上这个是平介与直子的秘密，就算直子告诉了藻奈美，她也想人妈妈看她的婚礼，但是完全没有必要重新搞过一遍啊。只有一个可能了，直子还活着，九年来她都在演戏，演直子慢慢消失的戏。平介不敢相信，他想的结果他立马跑去了婚礼现场去看看直子的反应、表情。原文中；<u>爸爸，她说，这么长时间以来，真的是好长好长时间以来，多亏您的照顾....她的声音已经哽咽了。</u><br>
<strong>读书笔记</strong><br>
<font color="bule">正所谓一千个读者就有一千个哈姆雷特</font>这里的想法就属于个人的愚见仅供参考。<br>
<font color="green">秘密</font>在百度百科中的解释释义：<font color="bule">1、指有所隐蔽，不为人知；2、隐蔽不为人知的事情或事物；3、佛教指隐秘深奥之法。4、隐蔽；不让人知道的。亦指隐蔽不让人知道的事情。</font>这本是叫《秘密》很显然这里是指第1，2，4的意思了，结合本书的平介与藻奈美和直子，他们之间必有一个或者全部都有隐瞒的事情，藻奈美为了安慰父亲失去妻子痛自己也不相信妈妈为了保护她而死去了。在极强的压力下出现了直子的人格。平介也可能知道藻奈美是在骗他，但是他也愿意深陷其中。这件事是他们三个人之间秘密。<br>
另外这本小说还有一个矛点，直子在见了文也（新郎）之后九里都没见过面了，第一次见面是在他们家里一起吃饭的时候就看了一眼迟疑了一下，在之前的剧情里直子对于司机家还是有点怀恨的，况且我不相信这个世界上有一见钟情的说法，一见钟情的背后必有极大的阴谋，直子嫁过去很可能是报复他的<br>
又或者是真的是为了在创造藻奈美的人出现，毕竟平介的生命是有限的，他们的秘密在平介死后的时间，没人会相信他们的秘密了，如果直子一直以这种状态下去很可能会怀恨一辈子</p>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[吴晓俊是sb]]></title>
        <id>https://rerunbug.github.io/wu-xiao-jun-shi-sb/</id>
        <link href="https://rerunbug.github.io/wu-xiao-jun-shi-sb/">
        </link>
        <updated>2020-11-03T15:51:03.000Z</updated>
        <content type="html"><![CDATA[<p>吴晓俊是sb</p>
]]></content>
    </entry>
</feed>