<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rerunbug.github.io</id>
    <title>Ruble</title>
    <updated>2021-06-30T07:48:46.756Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rerunbug.github.io"/>
    <link rel="self" href="https://rerunbug.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://rerunbug.github.io/images/avatar.png</logo>
    <icon>https://rerunbug.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Ruble</rights>
    <entry>
        <title type="html"><![CDATA[poplay直播源]]></title>
        <id>https://rerunbug.github.io/t_0qzRAKS/</id>
        <link href="https://rerunbug.github.io/t_0qzRAKS/">
        </link>
        <updated>2021-06-30T07:47:32.000Z</updated>
        <content type="html"><![CDATA[<p>https://iptv-org.github.io/iptv/index.m3u</p>
<p>https://github.com/imDazui/Tvlist-awesome-m3u-m3u8#%E6%8F%92%E4%BB%B6</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Java中方法中的形参为类的问题]]></title>
        <id>https://rerunbug.github.io/_nxRvZmyc/</id>
        <link href="https://rerunbug.github.io/_nxRvZmyc/">
        </link>
        <updated>2021-06-26T13:50:05.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">import java.util.*;

class Circle2D{
    private double x, y,radius;
    public void getLocation(double x, double y){
        this.x = x;
        this.y = y;
    }
    public void getRadius(double r){
        radius=r;
    }
    Circle2D(){
        this.x = 0;
        this.y = 0;
        this.radius =1;
    }
    Circle2D(double x, double y,double radius){
        this.x = x;
        this.y = y;
        this.radius = radius;
        // System.out.println(&quot;The area is &quot;+getArea());
        // System.out.println(&quot;The perimeter is &quot;+getPerimeter());
    }
    public double getArea(){
        return Math.PI*Math.pow(this.radius, 2);
    }
    public double getPerimeter(){
        return Math.PI*this.radius*2;
    }
    public boolean contains(double M,double N){
        if((Math.pow(M-this.x,2)+Math.pow(N-this.y,2))&gt;Math.pow(this.radius, 2)){
            return true;
        }
        else
        return false;
    }
    // 两圆之间内切 d=r1-r2
    // 两圆之间内含 d&lt;r1-r2
    // d 为两圆圆心的坐标应用两点间的距离公式
    public boolean contains(Circle2D circle) {
        return Math.pow((circle.x-this.x),2)+Math.pow((circle.y-this.y),2)&lt;=Math.abs(circle.radius-this.radius);
        //d&lt;=R-r;
    }
    public boolean overlaps(Circle2D circle) {
        return Math.pow((circle.x-this.x),2)+Math.pow((circle.y-this.y),2)&gt;Math.abs(circle.radius-this.radius)&amp;&amp;Math.pow((circle.x-this.x),2)+Math.pow((circle.y-this.y),2)&lt;circle.radius+this.radius;
        //R-r&lt;d&lt;R+r
    }
} 

public class Circle2DTest {
    static Circle2D cl=new Circle2D();
    private static void cl(Circle2D circle2d) {
        System.out.println(&quot;The area is &quot;+circle2d.getArea());
        System.out.println(&quot;The perimeter is &quot;+circle2d.getPerimeter());
    }
    
    public static void main(String[] args) {
        cl(new Circle2D(2,2,5.5));
        System.out.println(&quot;The points contains is &quot;+cl.contains(3,3));
        System.out.println(&quot;The circle contains is &quot;+cl.contains(new Circle2D(4,5,10.5)));
        System.out.println(&quot;The circle contains is &quot;+cl.contains(new Circle2D(3,5,2.3)));
    }
}
</code></pre>
<p>注意Circle2DTest类中的方法cl，形参为Circle2D circle2d 如果想要调用其类中的成员变量和方法必须得<strong>变量名.方法</strong>，我们可以把该形参看做（数据类型 变量名）的命名方式。</p>
<p>如果不这样做会导致该方法使用默认值来返回一个一个数值</p>
<p>错误案例</p>
<pre><code class="language-java">public class Circle2DTest {
    static Circle2D cl=new Circle2D();
    private static void cl(Circle2D circle2d) {
        System.out.println(&quot;The area is &quot;+cl.getArea());
        System.out.println(&quot;The perimeter is &quot;+cl.getPerimeter());
    }
    
    public static void main(String[] args) {
        cl(new Circle2D(2,2,5.5));
        System.out.println(&quot;The points contains is &quot;+cl.contains(3,3));
        System.out.println(&quot;The circle contains is &quot;+cl.contains(new Circle2D(4,5,10.5)));
        System.out.println(&quot;The circle contains is &quot;+cl.contains(new Circle2D(3,5,2.3)));
    }
}
</code></pre>
<p>如果这样子就会引用到Circle2D类中的方法Circle2D的无参构造了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[追风筝的人]]></title>
        <id>https://rerunbug.github.io/6JWVqqmzH/</id>
        <link href="https://rerunbug.github.io/6JWVqqmzH/">
        </link>
        <updated>2020-12-06T13:57:51.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://rerunbug.github.io/post-images/1607263132678.jpg" alt="" loading="lazy"><br>
作者：[美] 卡勒德·胡赛尼<br>
对于这本书我想说，它更像是在讲述一个真实且就好像是发生在身边是事情那样。这本书给我的力量绝非一般而是很大。时间真的可以将过去的种种冲淡吗？还是我们不愿意去面对，而选择去逃避。而真正的勇士是敢于面对生活的惨淡，敢于正视淋漓的鲜血。勇士是敢于知道这个世界的真相之后还敢于直面生活的人。<br>
阿富汗的少爷阿米尔和其仆人哈桑。在童年时，哈桑是一个放风筝的天才，至于掉落的风筝他都能准确无误的预判到风筝掉落的地方，在阿米尔问他是怎么知道的，哈桑又反问少爷：“我有骗过你吗？<font color="red">为你，千千万万遍。</font>看到这里我就回想到了小时候也曾经有过这一段真挚的友情。<font color="red">为你，千千万万遍。</font>这句话在一个未经世事的儿童口中说出来我认为此子将来在肯定是一个很重情谊的人，是一个很值得交的朋友，但是在社会上很容易吃亏的人。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[哥儿]]></title>
        <id>https://rerunbug.github.io/KXm_pk_us/</id>
        <link href="https://rerunbug.github.io/KXm_pk_us/">
        </link>
        <updated>2020-11-25T02:17:49.000Z</updated>
        <content type="html"><![CDATA[<p><strong>作者：夏目漱石</strong><br>
<img src="https://rerunbug.github.io/post-images/1606270829037.jpg" alt="" loading="lazy"><br>
我第次看夏目漱石的作品是《心》讲述的是一个孤独患者的故事。现在忘记的差不多了。<br>
《哥儿》中的少爷的原型是 弘中又一，少爷是一个作事仅凭个人感觉做事的人，正如清婆<br>
说的“少爷您善良，正义”少爷在我们中国古代就有一种侠客的风范，少爷在物理学院毕业<br>
后就远离了东京去了一个偏僻的地方教书了，在哪里遇见了“红衬衫”，”豪猪“，”蹩脚帮“<br>
，&quot;狗瓘”。少爷起初还以为“豪猪”是坏人结果是“红衬衫”“蹩脚帮”才是坏人第一点挑唆<br>
学生去我的蚊帐里面放蚂蚱，在去“红衬衫”家吃饭下套让我们去劝架，结果诱导报社写我们去<br>
打架了。反而“红衬衫”整天把为人师表，要严于律己，身为老师要起带头作用。“豪猪”与少爷<br>
都是不懂如何在人世中圆滑出世的”侠客“少爷就是一种被别人卖了还在为别人数钱的人。”蹩脚帮“<br>
与”红衬衫“狼狈为奸。而”狗瓘“作为校长却无作为。少爷与”豪猪“采用了比较侠客的方法报复<br>
了回去，在妓院的门口蹲点等他们出现打了一顿，又以侠客的方式声明我就在旅馆等他们报警啥的，<br>
仿佛就像告诉他你要来报复我，我随时恭候的到来。<br>
这篇小说通篇看下来毫无压力看完后还有点爽，我内心也住着个侠客，但是如果在现代为人不圆滑就会成为别人砧板上的鱼肉，少爷与”豪猪“他们虽然成功了，但是也失去了教师的工作，少爷从40元/月的工作去到了25元/月的工作而且还很辛苦，写到这里我想到了一个很中二的台词：”错的不是我，而是这个世界“在文章的结尾夏目漱石还写了一段关于清婆的事情清婆死与肝炎，缺少清婆的少爷如何在这个两面三刀的世界上活着，在往后的几年里少爷是否还能保持初心呢？是否成为了与这个世界同流合污的那一类人呢？现在问题仿佛就像是在问读者。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[冒泡排序法]]></title>
        <id>https://rerunbug.github.io/tQVI77KYT/</id>
        <link href="https://rerunbug.github.io/tQVI77KYT/">
        </link>
        <updated>2020-11-14T15:17:53.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://rerunbug.github.io/post-images/1605367181856.png" alt="" loading="lazy"><br>
<img src="https://rerunbug.github.io/post-images/1605367188199.png" alt="" loading="lazy"></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int bubbleSort(int a[], int N) {
	int sw = 0;
	bool flag = 1;
	for (int i = 0; flag; i++) {
		flag = 0;
		for (int j = N - 1; j &gt;= i + 1; j--) {
			//大于为降序，小于为升序。
			if (a[j] &lt; a[j - 1]) {
				//交换相邻元素      这里也可以用指针来表示
				swap(a[j], a[j - 1]);//int *temp;
				flag = 1;               //*temp=a[j];
				sw++;                  //a[j]=a[j-1];
			}                               //a[j-1]=*temp;
		}
	}
	return sw;
}
int main()
{
	int a[100], n, sw;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; a[i];
	}
	sw = bubbleSort(a, n);
	for (int i = 0; i &lt; n; i++) {
		if (i)cout &lt;&lt; &quot; &quot;;
		cout &lt;&lt; a[i];
	}
	cout &lt;&lt; endl;
	cout &lt;&lt; sw &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>冒泡排序法用c++比较方便一些<br>
可以看到作比较的函数是数组的最后一个与倒数第二个<br>
作比较的（众所周知3个数组里面所分配的空间命名为<br>
a[0],a[1],a[2]是从0到n-1个数来分配内存空间的）如果<br>
大于就将他们的值交换。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[插入排序法]]></title>
        <id>https://rerunbug.github.io/RQJCmKtJJ/</id>
        <link href="https://rerunbug.github.io/RQJCmKtJJ/">
        </link>
        <updated>2020-11-14T15:05:47.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://rerunbug.github.io/post-images/1605366613526.png" alt="" loading="lazy"><br>
<img src="https://rerunbug.github.io/post-images/1605366622087.png" alt="" loading="lazy"></p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
//按顺序输出数组元素
void trace(int A[], int N)
{
	int i;
	for (i = 0; i &lt; N; i++) {
		if (i &gt; 0)printf(&quot; &quot;);//在相邻元素之间输出1个空格
		printf(&quot;%d&quot;, A[i]);
	}
	printf(&quot;\n&quot;);
}
//插入排序（0起点数组）
void insertionSort(int A[], int N) {
	int j, i, v;
	for (i = 1; i &lt; N; i++) {
		v = A[i];
		j = i - 1;
		while (j &gt;= 0 &amp;&amp; A[j] &gt; v) {
			A[j + 1] = A[j];
			j--;
		}
		A[j + 1] = v;
		trace(A, N);
	}
}
int main() {
	int N, i;
	int A[100];
	scanf_s(&quot;%d&quot;, &amp;N);
	for (i = 0; i &lt; N; i++)scanf_s(&quot;%d&quot;, &amp;A[i]);
	trace(A, N);
	insertionSort(A, N);
	return 0;
}
</code></pre>
<p>第一次循环a[0]和a[1]作对比如果a[0]大于等于0并且大于a[1]<br>
就把a[0]的值与a[1]的值交换。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Using Git]]></title>
        <id>https://rerunbug.github.io/UEcFGE4HJ/</id>
        <link href="https://rerunbug.github.io/UEcFGE4HJ/">
        </link>
        <updated>2020-11-13T11:24:45.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Git下载链接</strong><br>
<a href="https://gitforwindows.org/">Git</a><br>
一路安装下去<br>
<img src="https://rerunbug.github.io/post-images/1605267005371.jpg" alt="" loading="lazy"><br>
按照这样设置<br>
安装好后我们鼠标右键会发现多出了两个命令<br>
一个是Git GUI Here   和   Git Bash Here<br>
我们新建一个<font color="red">空</font>文件夹<br>
然后打开这个文件夹鼠标右键按Git Bash Here<br>
等一会会出现<br>
<img src="https://rerunbug.github.io/post-images/1605267312288.jpg" alt="" loading="lazy"><br>
键入git init 命令注意空格<br>
查看文件夹的隐藏文件会发现多出一个文件.git<br>
在gitee or github 新建好一个仓库以后。<br>
我们键入git remote origin 加上地址<br>
origin 可以任意名称<br>
我们可以键入git remote -v查看是否完成了导入仓库<br>
git add . 代表添加所用文件注意  .  的空格<br>
git add 文件名<br>
git status 查看添加目录<br>
git commit -m&quot;&quot;   添加描述 必须的<br>
git push origin master 推送到git上<br>
有时候我们无法成功推送上去我们可以键入<br>
git push origin master -f 命令强制推送上去<br>
在团队项目中我们要养成push前要pull项目<br>
git pull origin master<br>
要不然会把之前队友的文件覆盖了的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ESP定律]]></title>
        <id>https://rerunbug.github.io/aREf_pDTx/</id>
        <link href="https://rerunbug.github.io/aREf_pDTx/">
        </link>
        <updated>2020-11-08T06:56:27.000Z</updated>
        <content type="html"><![CDATA[<p><font color="red">ESP定律又名堆栈平衡定律。</font><br>
<strong>典型的壳有UPX壳</strong><br>
<img src="https://rerunbug.github.io/post-images/1604819295812.jpg" alt="" loading="lazy"><br>
pushad是一个很典型的入栈代码<br>
我们在这里F8一下注意寄存器的ESP那边，只有ESP那边标红了<br>
<img src="https://rerunbug.github.io/post-images/1604819553832.jpg" alt="" loading="lazy"><br>
然后我们在红字部分转到内存部分<br>
在第一个字节下一个硬件访问断点4字节<br>
然后F9来到<br>
<img src="https://rerunbug.github.io/post-images/1604819891609.jpg" alt="" loading="lazy"><br>
看到0046DE7C这里的jmp是一个大跳转F8过去就来到了<br>
OEP<br>
<img src="https://rerunbug.github.io/post-images/1604820089795.jpg" alt="" loading="lazy"><br>
因为这只是一个压缩壳，所以他没有加密IAT直接脱就好了<br>
这里我们用dbg自带的插件来脱<br>
按ctrl+i<br>
<img src="https://rerunbug.github.io/post-images/1604820279590.jpg" alt="" loading="lazy"><br>
OEP自动填写上去了<br>
之后我们按IAT Autosearch按钮之后VA和SIZE的数据也会帮我们填上去了<br>
然后按Get Imports后我们可以看到表格里面列有很多数据<br>
我们把打<font color="red">×</font>的数据按鼠标右键Delte tree node删除即可<br>
然后按Dump按钮会得到一个exe文件，注意这个无法打开的我们还需要Fix Dump文件<br>
按下这个按钮选择我们刚刚得到的Dump文件即可运行了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[子序列的和（subsequence）]]></title>
        <id>https://rerunbug.github.io/xdJMwwQ9W/</id>
        <link href="https://rerunbug.github.io/xdJMwwQ9W/">
        </link>
        <updated>2020-11-07T10:24:27.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://rerunbug.github.io/post-images/1604744763984.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
double c;
int main()
{
	long long int n, m,a,j=1;
	while (scanf_s(&quot;%lld %lld&quot;, &amp;n, &amp;m) !=EOF)
	{
		if (n == 0 &amp;&amp; m == 0)break;
		for (a=n; a &lt;= m; a++)
		{
			c +=1.0/(a*a);
		}
		printf(&quot;Case %d:&quot;, j++);
		printf(&quot;%.5lf\n&quot;, c);
	}
	return 0;
}
</code></pre>
<p><strong>在c+=1.0/(a*a)这里我也中了坑，c语言里面int/int 得到的是int型的数据，而int/float类型的数据就会强制转化为int型的数据。只有float/float才会为有小数的值</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[水仙花数（daffodil）]]></title>
        <id>https://rerunbug.github.io/1sX5M7cRx/</id>
        <link href="https://rerunbug.github.io/1sX5M7cRx/">
        </link>
        <updated>2020-11-07T07:40:04.000Z</updated>
        <content type="html"><![CDATA[<p><strong>输出 100~999 中的所有水仙花数。若 3 位数 ABC 满足 ABC=A3+B3+C3，则称其为水仙<br>
花数。例如 153=13+53+33，所以 153 是水仙花数</strong></p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
const int max = 999;
int main()
{
	for (int min = 100; min &lt;= max; min++) {
		int a = min / 100;//百分位
		int b = (min % 100) / 10;//十分位
		int c = min % 10;//个分位
		if ((a * a * a) + (b * b * b) + (c * c * c)==min)printf(&quot;%d\n&quot;, min);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>